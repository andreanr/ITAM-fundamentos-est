{
    "collab_server" : "",
    "contents" : "uni.slice <- function (x0, g, w=1, m=Inf, lower=-Inf, upper=+Inf, gx0=NULL){\n\t# Modifications were made so that no global variables are used. (C DuBois)\n\t# Referencia: https://github.com/doobwa/MCMC.jl/blob/master/examples/slice.r\n\n\t#####################################\n\t# R FUNCTIONS FOR PERFORMING UNIVARIATE SLICE SAMPLING.\n\t#\n\t# Radford M. Neal, 17 March 2008.\n\t#\n\t# Implements, with slight modifications and extensions, the algorithm described\n\t# in Figures 3 and 5 of the following paper:\n\t#\n\t#   Neal, R. M (2003) \"Slice sampling\" (with discussion), Annals of Statistics,\n\t#      vol. 31, no. 3, pp. 705-767.\n\t#\n\t# See the documentation for the function uni.slice below for how to use it.\n\t# The function uni.slice.test was used to test the uni.slice function.\n\n\n\t# GLOBAL VARIABLES FOR RECORDING PERFORMANCE.\n\n\n\t# UNIVARIATE SLICE SAMPLING WITH STEPPING OUT AND SHRINKAGE.\n\t#\n\t# Performs a slice sampling update from an initial point to a new point that \n\t# leaves invariant the distribution with the specified log density function.\n\t#\n\t# Arguments:\n\t#\n\t#   x0    Initial point\n\t#   g     Function returning the log of the probability density (plus constant)\n\t#   w     Size of the steps for creating interval (default 1)\n\t#   m     Limit on steps (default infinite)\n\t#   lower Lower bound on support of the distribution (default -Inf)\n\t#   upper Upper bound on support of the distribution (default +Inf)\n\t#   gx0   Value of g(x0), if known (default is not known)\n\t#\n\t# The log density function may return -Inf for points outside the support \n\t# of the distribution.  If a lower and/or upper bound is specified for the\n\t# support, the log density function will not be called outside such limits.\n\t#\n\t# The value of this function is the new point sampled, with an attribute\n\t# of \"log.density\" giving the value of the log density function, g, at this\n\t# point.  Depending on the context, this log density might be passed as the \n\t# gx0 argument of a future call of uni.slice. \n\t#\n\t# The global variable uni.slice.calls is incremented by one for each call\n\t# of uni.slice.  The global variable uni.slice.evals is incremented by the\n\t# number of calls made to the g function passed.\n\t#\n\t# WARNING:  If you provide a value for g(x0), it must of course be correct!\n\t# In addition to giving wrong answers, wrong values for gx0 may result in\n\t# the uni.slice function going into an infinite loop.\n\n  # Check the validity of the arguments.\n\n  if (!is.numeric(x0) || length(x0)!=1\n   || !is.function(g) \n   || !is.numeric(w) || length(w)!=1 || w<=0 \n   || !is.numeric(m) || !is.infinite(m) && (m<=0 || m>1e9 || floor(m)!=m)\n   || !is.numeric(lower) || length(lower)!=1 || x0<lower\n   || !is.numeric(upper) || length(upper)!=1 || x0>upper\n   || upper<=lower \n   || !is.null(gx0) && (!is.numeric(gx0) || length(gx0)!=1))\n  { \n    stop (\"Invalid slice sampling argument\")\n  }\n\n  # Keep track of the number of calls made to this function.\n  uni.slice.calls <- 0\t# Number of calls of the slice sampling function\n  uni.slice.evals <- 0\t# Number of density evaluations done in these calls\n\n\n  uni.slice.calls <- uni.slice.calls + 1\n\n  # Find the log density at the initial point, if not already known.\n\n  if (is.null(gx0)) \n  { uni.slice.evals <- uni.slice.evals + 1\n    gx0 <- g(x0)\n  }\n\n  # Determine the slice level, in log terms.\n\n  logy <- gx0 - rexp(1)\n\n  # Find the initial interval to sample from.\n\n  u <- runif(1,0,w)\n  L <- x0 - u\n  R <- x0 + (w-u)  # should guarantee that x0 is in [L,R], even with roundoff\n\n  # Expand the interval until its ends are outside the slice, or until\n  # the limit on steps is reached.\n\n  if (is.infinite(m))  # no limit on number of steps\n  { \n    repeat\n    { if (L<=lower) break\n      uni.slice.evals <- uni.slice.evals + 1\n      if (g(L)<=logy) break\n      L <- L - w\n    }\n\n    repeat\n    { if (R>=upper) break\n      uni.slice.evals <- uni.slice.evals + 1\n      if (g(R)<=logy) break\n      R <- R + w\n    }\n  }\n\n  else if (m>1)  # limit on steps, bigger than one\n  { \n    J <- floor(runif(1,0,m))\n    K <- (m-1) - J\n\n    while (J>0)\n    { if (L<=lower) break\n      uni.slice.evals <- uni.slice.evals + 1\n      if (g(L)<=logy) break\n      L <- L - w\n      J <- J - 1\n    }\n\n    while (K>0)\n    { if (R>=upper) break\n      uni.slice.evals <- uni.slice.evals + 1\n      if (g(R)<=logy) break\n      R <- R + w\n      K <- K - 1\n    }\n  }\n\n  # Shrink interval to lower and upper bounds.\n\n  if (L<lower) \n  { L <- lower\n  }\n  if (R>upper)\n  { R <- upper\n  }\n\n  # Sample from the interval, shrinking it on each rejection.\n\n  repeat\n  { \n    x1 <- runif(1,L,R)\n\n    uni.slice.evals <- uni.slice.evals + 1\n    gx1 <- g(x1)\n\n    if (gx1>=logy) break\n\n    if (x1>x0) \n    { R <- x1\n    }\n    else \n    { L <- x1\n    }\n  }\n\n  # Return the point sampled, with its log density attached as an attribute.\n\n  attr(x1,\"log.density\") <- gx1\n  attr(x1,\"uni.slice.evals\") <- uni.slice.evals\n  attr(x1,\"uni.slice.calls\") <- uni.slice.calls\n  return (x1)\n  \n}\n#\n#\t-- END: uni.slice.R --",
    "created" : 1511720482625.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3376693385",
    "id" : "C890A8CE",
    "lastKnownWriteTime" : 1511720286,
    "last_content_update" : 1511720286,
    "path" : "/Volumes/MGA/proyecto_fundamentos/est46111_datos/Auxiliar/uni.slice.R",
    "project_path" : "est46111_datos/Auxiliar/uni.slice.R",
    "properties" : {
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}