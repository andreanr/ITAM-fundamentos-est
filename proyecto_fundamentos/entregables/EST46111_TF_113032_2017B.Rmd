---
title: "Examen Final Fundamentos de Estadística"
author: "Andrea Navarrete, Mariana Godina, Elizabeth Solis"
output:
  html_document: 
    df_print: paged
    highlight: tango
    theme: spacelab
    toc: yes
---

```{r options, echo = FALSE}
knitr::opts_chunk$set(
    comment = "",
    collapse = TRUE,
    message = FALSE,
    error=TRUE, 
    fig.align = "center",
    warning=FALSE, 
    echo = FALSE
)
```

## Contexto
Los datos diabetes-data.csv contienen la información de medición de glucosa en la sangre de 70 pacientes con diabetes observados en diferentes momentos del tiempo (horas, días, semanas, meses).

El contenido y formato de los datos es el siguiente:

a) Fecha (date) en formato MM-DD-YYYY
b) Hora (time) en formato XX:YY
c) Código (code)
d) Nivel de glucosa (value)
e) Indicadora de paciente (individual)

Los datos de concentración en la sangre se obtienen de dos fuentes:

+ Mediciones electrónicas automáticas  
+ Registros escritos en papel.   

Las mediciones eletrónicas automáticas se obtienen con etiquetas de tiempo específicas, mientras que las mediciones obtenidas de los registros *escritos* corresponden a *horarios ficticios* con la siguiente relación: Desayuno (08:00), comida (12:00), cena (18:00), y hora de dormir (22:00).

El campo code corresponde al tipo de insulina administrada al paciente.

Nota: La información de la adminitración de insulina, en este momento, es irrelevante.



```{r, warning=FALSE, message=FALSE, echo = FALSE}
# Lectura de datos
library(tidyverse)
library(readr)
library(stringr)
library(lubridate)
library(ggplot2)
library(plotly)
library(R2jags)

theme_set(theme_bw())
# Lectura de datos
diabetes <- read_csv("data_diabetes.csv", col_types = list(
  X1 = col_integer(),
  date = col_character(),
  time = col_time(format = ""),
  code = col_integer(),
  value = col_double(),
  individual = col_integer())) %>% 
  select(-X1)

# Catalogo de codigos
catalogo_code <- read_csv("catalogo_code.csv")

```

## Un primer vistazo a los datos

```{r, warning=FALSE, message=FALSE}
# Base de datos 
bd_diabetes <- diabetes %>% 
  left_join(catalogo_code)
  
summary(bd_diabetes)
glimpse(bd_diabetes)
```

## 1. ¿Existe discrepancia (en media o distribucional) entre las mediciones reportadas de registros escritos en papel y las que son reportadas electrónicamene?

+ Sabemos que las mediciones en papel se realizan en las siguientes horars: 
desayuno (08:00), comida (12:00), cena (18:00), y hora de dormir (22:00). 
El resto de las mediciones son consideradas como electrónicas.   
+ Con base en los datos podemos notar que no existe diferencia en 
las mediciones de glucosa.  
+ Podemos observar que las medias son muy similares, la media en 
papel es ligeramente más alta que la electrónica.  
+ Se muestra menor frecuencia en las mediciones de *papel* y esto se debe 
a que solo se realizan 4 veces al día (desayuno, comida, cena, dormir); no
obstante, las mediciones electrónicas se realizan con mayor frecuencia a 
lo largo del día.    
+ Lo anterior se refleja en la siguiente gráfica:  

```{r, warning=FALSE, message=FALSE, echo = FALSE}
bd_mediciones <- bd_diabetes %>% 
  mutate(atributo = str_replace_all(atributo, " ", "_")) %>% 
  filter(str_detect(atributo, "medición")) %>% 
  filter(value > 0)

# separamos escritos vs. aparato
escritos_hrs <- c(8, 12, 18, 22)
bd_mediciones <- bd_mediciones %>% 
  mutate(tipo=ifelse((hour(time) %in% escritos_hrs) &
          (minute(time) == 0), 'papel', 'electrónico'))

bd_mediciones <- bd_mediciones %>% 
  mutate(electronico=as.factor(ifelse((hour(time) %in% escritos_hrs) &
                       (minute(time) == 0), 1, 0)))

# Plot 
mean_papel <- subset(bd_mediciones, tipo == 'papel') %>% 
  select(value) %>% flatten_dbl() %>% mean(na.rm = TRUE)
mean_electronicos <- subset(bd_mediciones, tipo == 'electrónico') %>% 
  select(value) %>% flatten_dbl() %>% mean(na.rm = TRUE)

ggplot(bd_mediciones, aes(x=value, fill=tipo)) +
  geom_histogram(alpha=0.2, position="identity") +
  scale_fill_manual(values=c("cyan4", "magenta")) +
  geom_vline(aes(xintercept = mean_papel, color="magenta"), 
             show.legend = FALSE) + 
  geom_vline(aes(xintercept = mean_electronicos, color="cyan4"),
             show.legend = FALSE ) +
  ggtitle("Histograma de medición de glucosa con 2 tipos de registros") +
  labs(x = "Nivel de glucosa")
```

### Modelo diferencia mediciones en papel o electrónicas

A partir de lo anterior, puede extenderse el modelo para considerar un modelo jerárquico 
que responda si existe o no diferencias entre las mediciones. 

El modelo se define de la siguiente manera:

$$
log(y_{it}) \sim N(\mu_{it}, \tau_{i}) \\
\mu_{it} = \alpha_{i} + \beta_{i} * electrónico_{it} 
$$

Además:
$$
\alpha_{i} \sim N(0, 0.1) \\
\tau_{i} \sim gamma(c_0, c_1) \\
\beta \sim N(0, 0.01)
$$
donde:

+ $\alpha_i$ es el nivel general de glucosa de cada individuo *i*   
+ $electrónico_{it}$ indica si la medición fue realizada electrónicamente o en papel   

Para comprobar que no existen diferencias significativas entre las mediciones en papel o electrónicas tenemos que:
$$
H_{o}: \beta = 0 \\
H_{1}: \beta \neq 0
$$

```{r, warning=FALSE, message=FALSE, echo = FALSE}
modelo_diabetes_tipo.txt <- 
'
model
{
  #Likelihood
  for (i in 1:N) {
    y[i] ~ dnorm(mu[i], tau[indiv[i]])
    mu[i] <- alpha[indiv[i]] + beta[1] * x1[i]
  }

  c0 ~ dgamma(.001, 1)
  c1 ~ dgamma(1, 1)
  
  # Previas individuos
  for(i in 1:nindiv){
    alpha[i] ~ dnorm(0, 0.1)
    tau[i] ~ dgamma(c0, c1)
  }
  
  # Previas horas
  beta ~ dnorm(0, 0.01)
  
  ## predicciones
  for(i in 1:N) {
    yf1[i] ~ dnorm(mu[i], tau[indiv[i]])
  }
  }
'

cat(modelo_diabetes_tipo.txt, file = 'modelo_diabetes_tipo.txt')

N <- nrow(bd_mediciones)
y <- log(bd_mediciones$value)
indiv <- bd_mediciones$individual
nindiv <- length(unique(bd_mediciones$individual))
x1 <- bd_mediciones$electronico

inits<-function(){list(alpha = rep(0,n), beta = rep(0,2), yf1=rep(1,n))}
data <- list("y" = y, "N" = N, "indiv" = indiv, "nindiv" = nindiv, "x1" = x1)

jags.parameters <-  c("alpha","yf1", "beta", "tau")
jags.fit <- jags.parallel( 
  model.file = "modelo_diabetes_tipo.txt",
  data = data,
  parameters.to.save = jags.parameters,
  n.iter = 5000,
  n.thin = 1, 
  n.chains = 3,
  n.burnin = 1000,
  n.cluster = 7)
```

Siguiendo el modelo utilizando 5000 iteraciones, 3 cadenas y quemando las primeras 1000, se 
puede observar que cero pertenece al intervalo de la beta, por lo que no se rechaza la 
hipótesis nula, lo que implica que no existen diferencias entre las mediciones realizadas en 
papel o electrónicamente. 

```{r, warning=FALSE, message=FALSE, echo = FALSE}
out.dic<-jags.fit$BUGSoutput$DIC
out<-jags.fit$BUGSoutput$sims.list
out.sum<-jags.fit$BUGSoutput$summary

data.frame(Beta1 = out$beta) %>% 
  gather() %>% 
  ggplot(aes(x = value, fill = key)) +
  geom_histogram(alpha = .3) +
  scale_fill_discrete(name = "Parámetro")
```

Además, se puede observar que los valores generales de glucosa como su varianza varían por paciente como se muestra en las gráficas siguientes. 

```{r, warning=FALSE, message=FALSE, echo = FALSE}
out.alpha<-out.sum[grep("alpha",rownames(out.sum)),]

out.alpha %>% 
  data.frame() %>% 
  arrange(mean) %>% 
  ggplot(aes(x = 1:70, y = mean)) +
  geom_point() +
  geom_errorbar(aes(x=1:70, ymin = X2.5., ymax=X97.5.))
```

```{r, warning=FALSE, message=FALSE, echo = FALSE}
out.tau<-out.sum[grep("tau",rownames(out.sum)),]

out.tau %>% 
  data.frame() %>% 
  arrange(mean) %>% 
  ggplot(aes(x = 1:70, y = mean)) +
  geom_point() +
  geom_errorbar(aes(x=1:70, ymin = X2.5., ymax=X97.5.))
```

## 2. ¿ Existe discrepancia entre las mediciones de glucosa de los pacientes entre las cuatro horas del día donde se miden?

+ Supongamos que las `4 horas en las que se miden` se refiere a los registros
realizados antes del desayuno (08:00), comida (12:00), cena (18:00), y hora de dormir (22:00).        
+ Una vez identificados y filtrados estos horarios, notamos que las mediciones fueron realizadas 
antes de ingerir los alimentos como se muestra en la siguiente tabla:   

```{r, warning=FALSE, message=FALSE, echo = FALSE}
mediciones_41 <- bd_diabetes %>%
  filter(str_detect(atributo, "medición")) %>% 
  filter(hour(time) %in% c(8, 12, 18, 22), minute(time) == 0, second(time) == 0) %>% 
  mutate(horario = ifelse(hour(time) %in% c(8), "desayuno",
                   ifelse(hour(time) %in% c(12), "comida",
                   ifelse(hour(time) %in% c(18), "cena",
                   ifelse(hour(time) %in% c(22), "dormir","")))))

mediciones_41 %>% distinct(atributo)
```

+ En la gráfica que se presenta a continuación, notamos que las mediciones
realizadas en las 4 horas son muy similares, excepto por la medición antes 
de la comida.  
+ La medición de la comida es la que presenta más variación y `outliers`. 
También el primer, segundo y tercer cuartil son más bajos en relación al
resto de las mediciones.
+ Tiene sentido, ya que en el día es cuando existe el mayor gasto de energía; 
por lo que, la medición de las 12 (comida) será más baja y con más variación 
dependiendo de la actividad física de la persona.

```{r, warning=FALSE, message=FALSE, echo = FALSE}
ggplot(mediciones_41) +
  geom_boxplot(aes(x = "1", y = value, color = horario)) + 
  facet_grid(~horario) +
  theme(axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        axis.title.x=element_blank()) +
  ggtitle("Medición de glucosa") +
  labs(y = "Nivel de glucosa")
```

### Modelo diferencia mediciones en las 4 horas del día

Con base en lo anterior, sugerimos un modelo jerárquico para responder si existe 
discrepancia en las mediciones realizadas en las 4 distintas horas del día

El modelo sugerido es 

$$
log(y_{it}) \sim N(\mu_{i}, \tau_{i}) \\
\mu_{i} = \alpha_{ij} + \beta_{1} * horario8am_{i} + \beta_{2} * horario12pm_{i} + \beta_{3} * horario18pm_{i} + \beta_{4} * horario22pm_{i}
$$

Además:
$$
\alpha_{i} \sim N(0, 0.001) \\
\tau_{i} \sim gamma(c_0, c_1) \\
c0 \sim gamma(1, 1) \\
c1 \sim gamma(1, 1) \\
\beta_i \sim N(0, 0.001) \ ; \ i = 1,2,3,4

$$
donde:
+ $\alpha_i$ es el nivel de glucosa de cada individuo *i*, i = 1,2, ..., 70
+ $horario8am_{i}$ indica si la medición fue realizada en el desayuno  
+ $horario12pm_{i}$ indica si la medición fue realizada en la comida  
+ $horario18pm_{i}$ indica si la medición fue realizada en la cena  
+ $horario22pm_{i}$ indica si la medición fue realizada al dormir  

```{r, echo=FALSE}
modelo_horas <- '
model
{
  #Likelihood
  for (i in 1:n) {
  
  y[i] ~ dnorm(mu[i], tau[i])
  
  mu[i] <- alpha[indiv[i]] +
           beta[1] * horario_8am[i] +
           beta[2] * horario_12pm[i] +
           beta[3] * horario_18pm[i] +
           beta[4] * horario_22pm[i]
    
  }
  
  # Previas precisión mediciones
  for(j in 1:n){
    tau[j] ~ dgamma(c0, c1)
  }
  c0 ~ dgamma(1, 1)
  c1 ~ dgamma(1, 1)
  
  # Previas individuos
  for(i in 1:n_indiv){
    alpha[i] ~ dnorm(0, 0.001)
  }
  
  # Previas horas
  for(k in 1:m){
    beta[k] ~ dnorm(0, 0.001)
  }
  
  ## estimabilidad
  for(k in 1:m){
    beta.adj[k] <- beta[k] - mean(beta[])
  }
  
  
  ## predicciones
  for(i in 1:n) {
      yf1[i] ~ dnorm(mu[i], tau[i])
  }
}
'
cat(modelo_horas, file = 'modelo_horas')
```

El modelo se corrió con 3 distintas cadenas, 5000 iteraciones donde las primeras 1000 son de calentamiento

```{r, echo = FALSE}

mediciones_4 <- bd_diabetes %>%
  filter(str_detect(atributo, "medición"), value > 0 ) %>% 
  filter(hour(time) %in% c(8, 12, 18, 22), minute(time) == 0, second(time) == 0) %>% 
  mutate(horario_8am = ifelse((hour(time) %in% c(8) & minute(time) == 0 & second(time) == 0), 1, 0),
         horario_12pm = ifelse((hour(time) %in% c(12) & minute(time) == 0 & second(time) == 0), 1, 0),
         horario_18pm = ifelse((hour(time) %in% c(18) & minute(time) == 0 & second(time) == 0), 1, 0),
         horario_22pm = ifelse((hour(time) %in% c(22) & minute(time) == 0 & second(time) == 0), 1, 0),
         individual = as.factor(individual),
         atributo = as.factor(gsub("[ ]+","_",tolower(atributo)))) 

n <- mediciones_4 %>% nrow()
m <- 4
data <- list("n" = n, 
             "m" = m, 
             "n_indiv" =  length(unique(mediciones_4$individual)),
             "horario_8am" = mediciones_4$horario_8am, 
             "horario_12pm" = mediciones_4$horario_12pm, 
             "horario_18pm" = mediciones_4$horario_18pm, 
             "horario_22pm" = mediciones_4$horario_22pm,
             "indiv" = mediciones_4$individual,
             "y" = log(mediciones_4$value))

parameters2 <- c("beta", "beta.adj", "alpha", "yf1")

# Inits
inits <- function(){
  list(tau = rep(0.01,n),
       c0 = 0.5,
       c1 = 0.5,
       alpha = rep(0, n_indiv),
       beta = rep(0, m),
       yf1 = rep(0.5,n))
  }



fit_jags <- jags.parallel(data = data, 
                 parameters.to.save = parameters2,
                 model.file = "modelo_horas",
                 n.iter = 5000, 
                 n.chains = 3, 
                 n.cluster = 7, 
                 n.burnin = 10, 
                 n.thin = 1)


```

El resumen estadístico para las betas asociadas a las 4 horas se presentan a continuación y con 
esto podemos decir que 

+ La media de la beta2 que corresponde a la comida es la única que difiere significativamente 
con respecto al resto de las mediciones.   
+ El valor medio de las betas es positivo para todas, menos el de la comida.  
+ La Desviación estándar de las 4 horas es muy similar.  
+ De igual manera, se muestra el limite inferior y superior del IC al 95%   


```{r, echo=FALSE}
out.sum <- cbind(fit_jags$BUGSoutput$summary %>% 
  data.frame, parametro = rownames(fit_jags$BUGSoutput$summary)) %>% 
  dplyr::select(parametro, mean:X97.5.)
row.names(out.sum) <- NULL
colnames(out.sum) <- c("parametro", "media", "sd", "p.025", "p.25",
                       "p.5", "p.75", "p.975")
out.sum %>% filter(str_detect(parametro, "beta.adj")) %>% select(-p.25,-p.5, -p.75)
```

A continuación se muestra una gráfica `boxplot` con las betas asociadas a cada momento 
(desyauno/comida/cena/dormir)  y observamos lo que habiamos notado:

+ La única con niveles bajos de glucosa es a la hora de la comida. El 
resto, difieren ligeramente entre ellos por lo que en conclusión podríamos 
decir que sí existe discrepancia en las mediciones pero es más evidente 
en la medición de las 12 (a la hora de la comida) que se debe a lo explicado 
previamente.

```{r, echo=FALSE}
out.sum <- cbind(fit_jags$BUGSoutput$summary %>% 
  data.frame, parametro = rownames(fit_jags$BUGSoutput$summary)) %>% 
  dplyr::select(parametro, mean:X97.5.)
row.names(out.sum) <- NULL
colnames(out.sum) <- c("parametro", "media", "sd", "p.025", "p.25",
                       "p.5", "p.75", "p.975")


fit_jags$BUGSoutput$sims.matrix %>% 
  as.data.frame() %>% 
  dplyr::select(contains("beta.adj")) %>%
  mutate(id = row_number()) %>% 
  gather(parametro, valor, -id) %>% 
  mutate(parametro = gsub("[1]", "desayuno",parametro),
         parametro = gsub("[2]", "comida",parametro),
         parametro = gsub("[3]", "cena",parametro),
         parametro = gsub("[4]", "dormir",parametro)) %>% 
  ggplot(aes(x = parametro, y = valor, col = parametro)) +
  geom_boxplot() +
  coord_cartesian(ylim = c(-.15, .15))

```



## 3. ¿ Existe discrepancia de las mediciones de glucosa entre pacientes?

+ En la gráfica que se presenta a continuación podemos notar que sí existe 
diferencia en las mediciones medias de cada individuo.  
+ Existen individuos muy por debajo de la media global y también por arriba. 
Incluso, hay algunos que estan por encima del tercer cuartil. 
```{r, warning=FALSE, message=FALSE, fig.height=8, echo=FALSE}

medidas_grls <- bd_diabetes %>% 
  filter(value > 0) %>% 
  summarise(media_global = mean(value, na.rm = TRUE), 
            mediana = median(value, na.rm = TRUE),
            q1 = quantile(value,.25),
            q3 = quantile(value,.75))

medidas_medias_inidv <- bd_diabetes %>% filter(value > 0) %>% 
  group_by(individual) %>% 
  summarise(media_medicion_glucosa = mean(value, na.rm = TRUE))

ggplot(medidas_medias_inidv,aes(x = reorder(individual,media_medicion_glucosa), y = media_medicion_glucosa)) +
  geom_bar(stat = "identity", fill = "cyan3", alpha = 0.5) + coord_flip() +
  ggtitle("Medición media de glucosa por individuo") + 
  geom_hline(aes(yintercept = medidas_grls$media_global, color="media_global")) + 
  geom_hline(aes(yintercept = medidas_grls$q1, color="q1")) + 
  geom_hline(aes(yintercept = medidas_grls$q3, color= "q3")) +
  labs(x = "id del individuo", y = "Nivel de glucosa")
```

+ En el siguiente boxplot, se puede notar que tenemos `outliers` y nuestro 
rango de datos tiene una gran variabilidad desde `50.04`hasta `121.67`.  
+ Existe discrepancia entre individuos aunque hay algunos  
similares entre ellos.  

```{r, echo=FALSE}
preg3.1 <-ggplot(medidas_medias_inidv) +
  geom_boxplot(aes(x = "1", y = media_medicion_glucosa), col = "royalblue") + 
  theme(axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        axis.title.x=element_blank()) +
  ggtitle("Medición media de glucosa por individuo") +
  labs(y = "Nivel de glucosa")
ggplotly(preg3.1)
```


## 4. ¿ Existe discrepancia entre las mediciones de glucosa asociadas con la administración de insulina con respecto a las demás?

```{r, warning=FALSE, message=FALSE, fig.width=8, echo=FALSE}
bd_diabetes %>% 
  filter(value>0) %>% 
  group_by(code, atributo) %>% 
  summarise(nivel_glucosa = mean(value, na.rm = TRUE)) %>% 
  ggplot(aes(x = code, y = nivel_glucosa, col = atributo)) +
  geom_point()+
  geom_text(aes(label=code),hjust=0, vjust=1)  +
  ggtitle("Nivel medio de glucosa por codigo (atributo)")

```

Sí, son más bajas:

+ Los codigos `33`,`34`,`35`,`36`  corresponden a administración de insulina medicada, 
por lo que ayuda a disminuir el nivel de glucosa en la sangre, por dicha razón estos 
códigos se asocian con niveles bajos de glucosa.  
+ El nivel más alto de glucosa es después del almuerzo y tiene sentido, pues después
de ingerir alimentos, la glucosa se eleva; por lo general, el almuerzo es de las 
comidas con mayor catidad de calorías.  
+ El resto de las mediciones son similares, pues no corresponden a administración de 
insulina.



## 5. ¿Existe una discrepancia clara entre los pacientes que reportan sus niveles de glocosa depués de haber ingerido más alimentos de lo usual?

+ En el diagrama de caja se observa que la mediana y le media del nivel de glucosa cuando el paciente ingiere más alimentos de lo usual (2) es mayor que los días que no comen más (1).

```{r,echo=FALSE}
base_ingesta <- bd_diabetes %>% 
  filter(atributo %in% c(atributo[str_detect(atributo, "medición")], 
                         atributo[str_detect(atributo, "ingestión de comida mayor")]),
         !is.na(atributo)) %>% 
  mutate(tipo = ifelse(str_detect(atributo,"medición"), "medicion", "ingesta")) %>% 
  group_by(date, individual, tipo) %>% 
  summarise(media_glucosa = mean(value)) %>%
  spread(tipo, media_glucosa, fill=1) %>% 
  ungroup() %>% 
  mutate(ingesta = ifelse(ingesta == 0, 2, ingesta)) 

ggplot(base_ingesta, aes(x = as.factor(ingesta), y = medicion, color = as.factor(ingesta))) +
  geom_boxplot(color = c("#42f4c5","#41cdf4")) +
  stat_summary(fun.y=mean, colour="darkred", geom="point", 
               shape=18, size=3) + 
  scale_color_manual(name = "Ingesta", values = c("Sí", "No")) +
  labs(title = "Boxplot mediciones de glucosa", x = "Ingesta mayor a lo usal",
       y = "nivel de glucosa") 
  
```


### Modelo diferencia consumo de alimentos

Para esta pregunta se realizó un modelo jeráquico, la jerarquía se aplica a nivel individuo en donde los individuos comparten la precisión. Esto nos permite mejorar la precisión de las estimaciones de los parámetros para los que no se tienen suficientes observaciones. Por ejemplo, en este caso tenemos individuos con menos días observados. 

En este primer modelo no se busca predecir el nivel de glucosa sino verificar si existe una diferencia clara entre los días que se ingieren más alimentos de lo usual.

Se crea una base con el promedio diario de glucosa con un indicador que especifica si en ese día el paciente ingirió más alimentos de lo normal.

```{r,echo=FALSE}
base_ingesta <- bd_diabetes %>% 
  filter(atributo %in% c(atributo[str_detect(atributo, "medición")], 
                         atributo[str_detect(atributo, "ingestión de comida mayor")]),
         !is.na(atributo)) %>% 
  mutate(tipo = ifelse(str_detect(atributo,"medición"), "medicion", "ingesta")) %>% 
  group_by(date, individual, tipo) %>% 
  summarise(media_glucosa = mean(value)) %>%
  spread(tipo, media_glucosa, fill=1) %>% 
  ungroup() %>% 
  mutate(ingesta = ifelse(ingesta == 0, 2, ingesta)) %>% 
  filter(medicion>2)
head(base_ingesta)
```

```{r,echo=FALSE}
library(R2jags)
prob<-function(x){
  out<-min(length(x[x>0])/length(x),length(x[x<0])/length(x))
  out
}

n <- nrow(base_ingesta)
n_indiv <- base_ingesta$individual %>% 
  unique() %>% 
  length()
data<-list("n"=n, "n_indiv" = n_indiv, "y"=base_ingesta$medicion, "x" = base_ingesta$ingesta,
           "indiv" = base_ingesta$individual)

inits<-function(){list(alpha = rep(0,n_indiv), beta = rep(0,2), yf1=rep(1,n))}

parameters<-c("alpha","beta.adj", "yf1")

mod.reg <-jags.parallel(data,inits,parameters,model.file="modelo_ingesta.txt",
               n.iter=5000,n.chains=1,n.burnin=1000, n.thin = 1, n.cluster = 7)
```

+ Simulaciones de los parámetros

```{r, echo=FALSE}
out<-mod.reg$BUGSoutput$sims.list
out.sum<-mod.reg$BUGSoutput$summary
```

En esta gráfica se observa que hay una discrepancia clara entre los días que ingieren más alimentos de lo usal. $Beta1$ es negativa y representa a los días que se consumió una cantidad normal de alimentos y $Beta2$ es positiva lo cual significa que el nivel de glucosa aumenta si se come más de lo normal.

```{r,echo=FALSE}
data.frame(Beta1 = out$beta.adj[,1], Beta2 = out$beta.adj[,2]) %>% 
  gather() %>% 
  ggplot(aes(x = value, fill = key)) +
  geom_histogram(alpha = .3) +
  scale_fill_discrete(name = "Parámetro")
```

Se grafica el parámetro $alpha$ para observar si existe alguna diferencia entre individuos. Observamos que se comportan de manera similar. (Los intervalos se empalman)

```{r,echo=FALSE}
out.alpha<-out.sum[grep("alpha",rownames(out.sum)),]

out.alpha %>% 
  data.frame() %>% 
  arrange(mean) %>% 
  ggplot(aes(x = 1:70, y = mean)) +
  geom_point() +
  geom_errorbar(aes(x=1:70, ymin = X2.5., ymax=X97.5.))
```

+ Resúmenes estadístico de los parámetros monitoreados

```{r,echo=FALSE}
out.sum[grep("beta", rownames(out.sum)), c(1,3,7)]

```

+ DIC

```{r,echo=FALSE}
out.dic<-mod.reg$BUGSoutput$DIC
out.dic
```


+ R2

```{r,echo=FALSE}
out.yf<-out.sum[grep("yf1",rownames(out.sum)),]

r2 <- cor(base_ingesta$media_glu, out.yf[,1])^2
r2
```

+ Devianza

```{r,echo=FALSE}
mean(out$deviance)
```

### Modelo nivel de glucosa

Queremos predecir la medición promedio de glucosa para un individuo cuando come una cantidad de alimentos normal o cuando se excede. 

Para plantear este modelo, construimos una base con el promedio de las mediciones por individuo, separando por el tipo de consumo.

```{r,echo=FALSE}
base_ingesta <- bd_diabetes %>% 
  mutate(hora = hour(time)) %>% 
  filter(atributo %in% c(atributo[str_detect(atributo, "medición")], atributo[str_detect(atributo, "ingestión de comida mayor")]),
         !is.na(atributo)) %>% 
  mutate(tipo = ifelse(str_detect(atributo,"medición"), "medicion", "ingesta")) %>% 
  group_by(date, individual, tipo) %>% 
  summarise(media_glucosa = mean(value)) %>% 
  spread(tipo, media_glucosa, fill = 1) %>% 
  ungroup() %>% 
  mutate(ingesta = ifelse(ingesta == 0, 2, ingesta),
         unos = 1) %>% 
  group_by(individual, ingesta) %>% 
  summarise(media_glu = mean(medicion)) %>% 
  filter(media_glu>2)

head(base_ingesta)
```

En exploratorio de los datos vimos que la mediana del nivel de gluscosa es mayor cuando se excede de la cantidad de alimentos habitual.

```{r,echo=FALSE}
n_indiv <- base_ingesta$individual %>% 
  unique() %>% 
  length()

n <- nrow(base_ingesta)

data<-list("n"=n, "n_indiv" = n_indiv, "y"=base_ingesta$media_glu, "x" = base_ingesta$ingesta, 
           "indiv" = base_ingesta$individual)

inits<-function(){list(alpha = rep(0,n_indiv), beta = rep(0,2), yf1=rep(1,n))}

parameters<-c("alpha","beta.adj", "yf1")

mod.reg <-jags.parallel(data,inits,parameters,model.file="modelo_ingesta.txt",
               n.iter=5000,n.chains=3,n.burnin=1000, n.thin = 1, n.cluster = 7)
```

+ Gráfica observado vs ajustado

En la gráfica de ajustados vs osbservados se aprecia que los puntos están alrededor de una linea de 45º. Podemos ver que sobreestimamos mediciones pequeñas y subestimas mediciones grandes.

```{r,echo=FALSE}
out<-mod.reg$BUGSoutput$sims.list
out.sum<-mod.reg$BUGSoutput$summary
out.yf<-out.sum[grep("yf1",rownames(out.sum)),]
data.frame(y_obs = base_ingesta$media_glu, y_pred = out.yf[,1]) %>% 
  ggplot(aes(x = y_obs, y = y_pred)) +
  geom_point() +
  xlim(80,240) +
  ylim(80, 240) +
  geom_abline(a = 0, b = 1, color = "red")
```

+ Intervalos de confianza

Los datos observados se encuentran dentro de nuestros intervalos de confianza.

```{r,echo=FALSE}
data.frame(y_obs = base_ingesta$media_glu, y_pred = out.yf[,1], y_inf = out.yf[,3],
           y_sup = out.yf[,7]) %>% 
  ggplot() +
  geom_point(aes(x = 1:n, y = y_obs)) +
  geom_point(aes(x = 1:n, y = y_pred), color = "red") +
  geom_errorbar(aes(x = 1:n, ymin = y_inf, ymax=y_sup))  +
  labs(x = "Observaciones", y = "Glucosa")
```

+ Simulaciones de los parámetros

Observamos que las betas indican una discrepancia entre la diferencia de la ingesta de alimentos, pero no es tan discrminante como el modelo anterior. Esto se puede deber a que estamos promediando individuos y no individuos-días. 

```{r,echo=FALSE}
data.frame(Beta1 = out$beta.adj[,1], Beta2 = out$beta.adj[,2]) %>% 
  gather() %>% 
  ggplot(aes(x = value, fill = key)) +
  geom_histogram(alpha = .3) +
  scale_fill_discrete(name = "Parámetro")
```

Se grafica el parámetro $alpha$ para observar si existe alguna diferencia entre individuos. Observamos que se comportan de forma similar. Sin embargo, en este caso hay alphas cuyos intervalos no se interceptan, entonces estos individuos sí tienen comportamiento distinto en sus mediciones de glucosa. 

```{r,echo=FALSE}
out.alpha<-out.sum[grep("alpha",rownames(out.sum)),]

out.alpha %>% 
  data.frame() %>% 
  arrange(mean) %>% 
  ggplot(aes(x = 1:70, y = mean)) +
  geom_point() +
  geom_errorbar(aes(x=1:70, ymin = X2.5., ymax=X97.5.))
```

En este modelo se obtiene un mejor DIC y $R^2$.

+ Resúmenes estadístico de los parámetros monitoreados

```{r,echo=FALSE}
out.sum[grep("beta", rownames(out.sum)), c(1,3,7)]

```

+ DIC

```{r,echo=FALSE}
out.dic<-mod.reg$BUGSoutput$DIC
out.dic
```


+ R2

```{r,echo=FALSE}
out.yf<-out.sum[grep("yf1",rownames(out.sum)),]

r2 <- cor(base_ingesta$media_glu, out.yf[,1])^2
r2
```

+ Devianza

```{r,echo=FALSE}
mean(out$deviance)
```

## Anexo

A continuación se muestra el código de los modelos asociados a la pregunta 1,2 y 5.

### Anexo: Modelo pregunta 1

```{r, eval=FALSE, echo = TRUE}

model
{
  #Likelihood
  for (i in 1:N) {
    y[i] ~ dnorm(mu[i], tau[indiv[i]])
    mu[i] <- alpha[indiv[i]] + beta[1] * x1[i]
  }

  c0 ~ dgamma(.001, 1)
  c1 ~ dgamma(1, 1)
  
  # Previas individuos
  for(i in 1:nindiv){
    alpha[i] ~ dnorm(0, 0.1)
    tau[i] ~ dgamma(c0, c1)
  }
  
  # Previas horas
  beta ~ dnorm(0, 0.01)
  
  ## predicciones
  for(i in 1:N) {
    yf1[i] ~ dnorm(mu[i], tau[indiv[i]])
  }
  }


```

### Anexo: Modelo pregunta 2

```{r, eval=FALSE, echo = TRUE}
model
{
  #Likelihood
  for (i in 1:n) {
  
  y[i] ~ dnorm(mu[i], tau[i])
  
  mu[i] <- alpha[indiv[i]] +
           beta[1] * horario_8am[i] +
           beta[2] * horario_12pm[i] +
           beta[3] * horario_18pm[i] +
           beta[4] * horario_22pm[i]
    
  }
  
  # Previas precisión mediciones
  for(j in 1:n){
    tau[j] ~ dgamma(c0, c1)
  }
  c0 ~ dgamma(1, 1)
  c1 ~ dgamma(1, 1)
  
  # Previas individuos
  for(i in 1:n_indiv){
    alpha[i] ~ dnorm(0, 0.001)
  }
  
  # Previas horas
  for(k in 1:m){
    beta[k] ~ dnorm(0, 0.001)
  }
  
  ## estimabilidad
  for(k in 1:m){
    beta.adj[k] <- beta[k] - mean(beta[])
  }
  
  
  ## predicciones
  for(i in 1:n) {
      yf1[i] ~ dnorm(mu[i], tau[i])
  }
}
```


### Anexo: Modelo pregunta 5

```{r, eval=FALSE, echo=TRUE}
model{

# Verosimilitud
for (i in 1:n) {

	y[i] ~ dgamma(r[i], lambda[i])
	eta[i] <- alpha[indiv[i]] + beta[x[i]]
	r[i] <- lambda[i]*mu[i]
	
	## Liga
	log(mu[i]) <- eta[i]
	}

#Priors 
for (i in 1:n_indiv) {
alpha[i] ~ dnorm(0,tau.a)
}

for (j in 1:2) { beta[j] ~ dnorm(0,0.001) }

tau.a ~ dgamma(0.001,0.001)

for(i in 1:n){lambda[i] ~ dunif(0,1)}

#Prediction 1
for (i in 1:n) { yf1[i] ~ dgamma(r[i], lambda[i]) }

#Estimable quentities
for(j in 1:2){
	beta.adj[j] <- beta[j] - mean(beta[])
}

}
```

